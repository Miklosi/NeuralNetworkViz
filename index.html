<!DOCTYPE html>
<meta charset="utf-8">
<meta http-equiv="Access-Control-Allow-Origin" content="*"/>

<style>

svg {
  /*position: absolute;*/
}

g.node {
  stroke: #fff;
  stroke-width: 1.5px;
}

line.link {
  stroke: #bdbdbd; /*#999;*/
  stroke-opacity: .6;
}

.d3-tip {
    line-height: 1;
    color: black;
    font-family: Arial;
    text-align: center;
}

.g-premium circle, circle.premium {
    fill: #00a3e0;
}
.g-claim circle, circle.claim {
    fill: #e4002b;

}

line.divider {
    stroke: #000; /*#666;*/
    stroke-width: 1;
}

circle.filler.outline {
    fill: #000;
    stroke: #000;
    stroke-width: 1.5;
}

</style>

<script type='text/javascript' src="./src/d3.v3.min.js"></script>
<script type='text/javascript' src="./src/d3.tip.js"> </script>
<script type="text/javascript" src='./src/math.js'></script>
<script type="text/javascript" src='./src/neural_network.js'></script>


<body>

  <div id="netoworkGraphContainer">
      
  </div>
  
  <div id="imageGenerator">
  </div>

<script>



//var training_data = [];
//var test_data = [];


//TODO: test self.backprop & write self.evaluate fns
  

var training = {
  inputs: [
    math.matrix([[0],[0]]),
    math.matrix([[0],[1]]),
    math.matrix([[1],[0]]),
    math.matrix([[1],[1]])
  ],
  targets: [
    [[0]],
    [[0]],
    [[0]],
    [[1]]
  ]    
};
training = d3.zip(training.inputs, training.targets);


//2 (input), 2 (hidden layer1), 1 (output)
var myNetwork = new NeuralNetwork([2,2,1]);

//testing backprop alg:
//myNetwork.backprop(training.inputs[0],training.targets[0]);










/*
function updateImage(dataRow) {

  var imgSVG = d3.select("#imageGenerator svg g");

  //data join
  var rect = imgSVG.selectAll('rect')
                   .data(dataRow.values);

  //note: assume square, so image is dimension*dimension
  var dimension = math.sqrt(dataRow.values.length);
  var pixelDimensions = 10;

  //update old elements as needed [only if enter().append("rect") is removed]

  function updatePixels(elem) {
    elem.attr({
    //rect.enter().append("rect")
        //.attr({
          width: pixelDimensions,
          height: pixelDimensions,
          x: function(d, i) {
            return pixelDimensions * parseInt(i % dimension);
          },
          y: function(d, i) {
            return pixelDimensions * parseInt(i / dimension);
          }
        }).style({
          fill: function (d,i) {
            return "rgb(" + d + "," + d + "," + d + ")";
          }
        });
  }

  updatePixels(rect);
  
  updatePixels(rect.enter().append("rect"));
    
  rect.exit().remove();

}



//d3.csv("./data/mnist_train_sample.csv", function(data) {
d3.text("./data/mnist_train_sample.csv", function(text) {
                      training_data = d3.csv.parseRows(text)
                                        .map(function(row) {
                                          return {
                                            result: +row.slice(0,1),
                                            values: row.slice(1).map(function(value) { return +value; })
                                          };
                                        });

                      var svg = d3.select("#imageGenerator")
                                  .append("svg")
                                  .attr({
                                    width: 280,
                                    height: 280
                                  })
                                  .append("g");

                      updateImage(training_data[0]);

                      //readyCheck("mnist_train_sample.csv");
                    });
*/

//var readyFiles = {'mnist_train_sample.csv': false, 'mnist_train_sample.csv': false};
//function readyCheck(filename) {
  //readyFiles[filename] = true;
//
  //if (readyFiles['mnist_train_sample']==true && readyFiles['mnist_train_sample']==true) {
    ////...begin drawing visualization...
//
  //}
//}














//math.matrix([[0, 1], [2, 3], [4, 5]]); 



var inputDimensions = 2, //nIn
    outputDimensions = 1, //nOut
    BIAS_VALUE = -1, //constant value for bias
    TRAINING_EPOCHS = 5001; //#1001, 5001

var inputs = math.matrix([
                   [0, 0],
                   [0, 1],
                   [1, 0],
                   [1, 1]
            ]),
    targets = math.matrix([
                   [0],
                   [1],
                   [1],
                   [1]
            ]);

var nData = inputs.size()[0], //4 in this case
    nHidden = 2, //no. hidden neurons
    learningrate = 0.25,
    momentum = 0.9,
    hidden = math.ones(nHidden+1,nData),
    outputType = "linear";

var initialiseFn = function(x) { return (Math.random() -.5) * 2/Math.sqrt(inputDimensions); };

                //weights from inputs to hidden neurons
var weights1 = math.ones(inputDimensions+1, nHidden)
                   .map(initialiseFn), 

                //weights from hidden neurons to outputs
    weights2 = math.ones(nHidden+1, outputDimensions)
                   .map(initialiseFn);


var addBiasColumnTo = function(matrix) {
    var nRows = matrix.size()[0], 
        nCols = matrix.size()[1];

    return matrix.resize([nRows, nCols+1])
                 .map(function(x, i) { 
                   return i[1] == nCols ? BIAS_VALUE : x; 
                 });
}


inputs = addBiasColumnTo(inputs);


function linearError(activations) {
  return math.dotMultiply(
                math.subtract(activations, targets),
                1/nData);
}

function logisticError(activations) {
  return math.dotMultiply.call(
                  math.subtract(activations, targets),
                  activations,
                  math.subtract(1, activations)
                );
}

function softmaxError(activations) {
  return math.dotMultiply.call(
                  math.subtract(activations, targets),
                  math.subtract(
                        activations,
                        math.dotMultiply.call(activations, activations, -1)
                  ),
                  1/nData
                );
}





function mlpFwd(inputs) {//

  //hidden activations (hidden: 4r*3c)
  hidden = math.multiply(inputs, weights1);//
     //math.divide(1, math.add(math.exp(math.multiply(-1,hidden)),1))
  hidden = hidden.map(function (value) {      
                         return 1/(1 + Math.exp(-1*value));
                     });
  hidden = addBiasColumnTo(hidden);

  //output activations 4r 1c
  var activations = math.multiply(hidden, weights2);

  switch (outputType) 
  {
    case 'linear':   
      return linearError(activations);
    case 'logistic':   
      return logisticError(activations);
    case 'softmax':   
      return softmaxError(activations);
  }


}



var updateW1 = math.zeros(weights1.size()[0],weights1.size()[1]),
    updateW2 = math.zeros(weights2.size()[0],weights2.size()[1]),
    activations = null;


for (var i=0; i<TRAINING_EPOCHS; i++) {
  
  //feed forward the inputs to get the current outputs
  activations = mlpFwd(inputs)

  //error <- 0.5 * sum((activations-targets)^2)
  //#if(error %% 100 == 0) break
  
  //amount to change weights2 by
  switch (outputType) 
  {
    case 'linear':   
      delta0 = linearError(activations);
      break;
    case 'logistic':   
      delta0 = logisticError(activations);
      break;
    case 'softmax':   
      delta0 = softmaxError(activations);
      break;
  }

  //amount to change weights1 by
    //-hidden * (1-hidden) * deltaO %*% t(weights2)
  deltaH = math.dotMultiply.call(
                    math.multiply(hidden, -1), 
                    math.subtract(1, hidden),
                    math.multiply(delta0, math.transpose(weights2))              
            );
    
  
  //updateW1 <- 
    //learningrate * 
    //(t(inputs) %*% deltaH[,-ncol(deltaH)]) + 
    //(momentum * updateW1)
  updateW1 = math.multiply(
                learningrate,
                math.add(
                  math.multiply(
                    math.transpose(inputs),
                    deltaH.resize([deltaH.size()[0],deltaH.size()[1]-1])
                  ),
                  math.multiply(momentum, updateW1)
                )
             );

  //updateW2 <- 
    //learningrate * 
    //(t(hidden) %*% deltaO) + 
    //(momentum * updateW2)
  updateW2 = math.multiply(
                learningrate,
                math.add(
                  math.multiply(
                    math.transpose(hidden),
                    delta0
                  ),
                  math.multiply(momentum, updateW2)
                )
             );


  weights1 = math.subtract(weights1, updateW1);
  weights2 = math.subtract(weights2, updateW2);
}

//
//testing: (if working output = target)
//mlpfwd(inputs)
//ifelse(mlpfwd(inputs) > .5,1,0)
console.log(
    math.format(
      activations.map(function(x) { 
                        return x > 0 ? 1 : 0 }), 
      1)
    );



hidden.map(function(x, i) { 
  return i.toString().replace(",","") 
})._data



var width = 500,
    height = 500,
    minCircleRadius = 0;


var graphMLPData = {
  nodes: [
    { name: "in1", group: 0, size: 25, x: width/4, y: height/3, fixed: true },
    { name: "in2", group: 1, size: 25, x: width/4, y: 2*height/3, fixed: true },


      { name: "biashidden1", group: 2, size: 25, x: 3*width/8, y: height/6, fixed: true },  
    { name: "hidden1", group: 3, size: 25, x: width/2, y: height/3, fixed: true },
    { name: "hidden2", group: 4, size: 25, x: width/2, y: 2*height/3, fixed: true },

      { name: "biasOut", group: 5, size: 25, x: 5*width/8, y: height/6, fixed: true },  
    { name: "out1", group: 6, size: 25, x: 3*width/4, y: height/2, fixed: true }
  ],
  links: [  //source & target: index in nodes array,   value:  strength of link 
      
    { source: 0, target: 3, value: 10, display: true },
    { source: 0, target: 4, value: 10, display: true },

    { source: 1, target: 3, value: 10, display: true },
    { source: 1, target: 4, value: 10, display: true },
      
    { source: 2, target: 3, value: 10, display: true },
    { source: 2, target: 4, value: 10, display: true },

    { source: 5, target: 6, value: 10, display: true },
    
    { source: 3, target: 6, value: 10, display: true },
    { source: 4, target: 6, value: 10, display: true },
     
  ]
};




var svg = d3.select("#netoworkGraphContainer").append("svg")
    .attr("width", width)
    .attr("height", height);

    function update(data) {


        var force = d3.layout.force()
                      .size([width, height])
                      .nodes(data.nodes)
                      .links(data.links)
                      .linkDistance(width/4);

        var links = svg.selectAll('.link')
            .data(data.links);

        links.enter()
             .append('line')
             .attr('class', 'link');

        var nodes = svg.selectAll(".node")
                      .data(data.nodes, function(d) { return d.name; }); //key fn
                      
        nodes.enter()
             .append("circle")
             .attr('class','node');

        //Set up tooltip
        var tip = d3.tip()
            .attr('class', 'd3-tip')
            .offset([-10, 0])
            .html(function (d) {
               return "<strong>" + d.name + "</strong><br/>" + d.size; //can be any html text if we want
            });
            svg.call(tip);

        nodes.on('mouseover', tip.show) 
             .on('mouseout', tip.hide); 

        force.on('tick', function() {

            nodes.attr({
                r: function(d) { return d.size; },
                cx: function(d) { return d.x; },
                cy: function(d) { return d.y; }
            });

            links.attr({
                x1: function(d) { return d.source.x; },
                y1: function(d) { return d.source.y; },
                x2: function(d) { return d.target.x; },
                y2: function(d) { return d.target.y; }
            });

        });

        force.start();

    }

    update(graphMLPData);


</script>
  

</body>

</html>