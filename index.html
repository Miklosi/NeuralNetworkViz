<!DOCTYPE html>
<meta charset="utf-8">
<meta http-equiv="Access-Control-Allow-Origin" content="*"/>

<style>

svg {
  /*position: absolute;*/
}

g.node {
  stroke: #fff;
  stroke-width: 1.5px;
}

line.link {
  stroke: #bdbdbd; /*#999;*/
  stroke-opacity: .6;
}

.d3-tip {
    line-height: 1;
    color: black;
    font-family: Arial;
    text-align: center;
}

.g-premium circle, circle.premium {
    fill: #00a3e0;
}
.g-claim circle, circle.claim {
    fill: #e4002b;

}

line.divider {
    stroke: #000; /*#666;*/
    stroke-width: 1;
}

circle.filler.outline {
    fill: #000;
    stroke: #000;
    stroke-width: 1.5;
}

</style>

<script type='text/javascript' src="./src/d3.v3.min.js"></script>
<script type='text/javascript' src="./src/d3.tip.js"> </script>
<script type="text/javascript" src='./src/math.js'></script>
<script type="text/javascript" src='./src/neural_network.js'></script>

<body>

  <div id="netoworkGraphContainer">
  </div>
  
  <div id="imageGenerator">
  </div>

<script>

var AND_training_data = [
    { value: math.matrix([[0],[0]]), target: [[0]] },
    { value: math.matrix([[0],[1]]), target: [[0]] },
    { value: math.matrix([[1],[0]]), target: [[0]] },
    { value: math.matrix([[1],[1]]), target: [[1]] }
  ],
  OR_training_data = [
    { value: math.matrix([[0],[0]]), target: [[0]] },
    { value: math.matrix([[0],[1]]), target: [[1]] },
    { value: math.matrix([[1],[0]]), target: [[1]] },
    { value: math.matrix([[1],[1]]), target: [[1]] }
  ],
  XOR_training_data = [
    { value: math.matrix([[0],[0]]), target: [[0]] },
    { value: math.matrix([[0],[1]]), target: [[1]] },
    { value: math.matrix([[1],[0]]), target: [[1]] },
    { value: math.matrix([[1],[1]]), target: [[0]] }
  ];

//2 (input), 1 (output)  <no hidden layers>
var mySimpleNetwork = new NeuralNetwork([2,1]);
//mySimpleNetwork.train(AND_training_data, 5000, AND_training_data.length, 0.25);
//mySimpleNetwork.evaluate(AND_training_data);

//2 (input), 2 (hidden layer1), 1 (output)
var myNetwork = new NeuralNetwork([2,2,1]);
//myNetwork.train(AND_training_data, 5000, AND_training_data.length, 0.25);
//myNetwork.evaluate(AND_training_data);

//784 (input), 30 (hidden layer1), 10 (output)
//var myCharacterRecognitionNetwork = new NeuralNetwork([784,30,10]);
//myCharacterRecognitionNetwork.train(img_training_data, 5000, img_training_data.length, 0.25);
//myCharacterRecognitionNetwork.evaluate(img_training_data);



/*
function updateImage(dataRow) {

  var imgSVG = d3.select("#imageGenerator svg g");

  //data join
  var rect = imgSVG.selectAll('rect')
                   .data(dataRow.values);

  //note: assume square, so image is dimension*dimension
  var dimension = math.sqrt(dataRow.values.length);
  var pixelDimensions = 10;

  //update old elements as needed [only if enter().append("rect") is removed]

  function updatePixels(elem) {
    elem.attr({
    //rect.enter().append("rect")
        //.attr({
          width: pixelDimensions,
          height: pixelDimensions,
          x: function(d, i) {
            return pixelDimensions * parseInt(i % dimension);
          },
          y: function(d, i) {
            return pixelDimensions * parseInt(i / dimension);
          }
        }).style({
          fill: function (d,i) {
            return "rgb(" + d + "," + d + "," + d + ")";
          }
        });
  }

  updatePixels(rect);
  
  updatePixels(rect.enter().append("rect"));
    
  rect.exit().remove();

}



//d3.csv("./data/mnist_train_sample.csv", function(data) {
d3.text("./data/mnist_train_sample.csv", function(text) {
                      training_data = d3.csv.parseRows(text)
                                        .map(function(row) {
                                          return {
                                            result: +row.slice(0,1),
                                            values: row.slice(1).map(function(value) { return +value; })
                                          };
                                        });

                      var svg = d3.select("#imageGenerator")
                                  .append("svg")
                                  .attr({
                                    width: 280,
                                    height: 280
                                  })
                                  .append("g");

                      updateImage(training_data[0]);

                      //readyCheck("mnist_train_sample.csv");
                    });
*/

//var readyFiles = {'mnist_train_sample.csv': false, 'mnist_train_sample.csv': false};
//function readyCheck(filename) {
  //readyFiles[filename] = true;
//
  //if (readyFiles['mnist_train_sample']==true && readyFiles['mnist_train_sample']==true) {
    ////...begin drawing visualization...
//
  //}
//}





var width = 500,
    height = 500,
    minCircleRadius = 0;
/*
// 2,2,1
var graphMLPData = {
  nodes: [
    { name: "in1", group: 0, size: 25, x: width/4, y: height/3, fixed: true },
    { name: "in2", group: 1, size: 25, x: width/4, y: 2*height/3, fixed: true },

//      { name: "biashidden1", group: 2, size: 25, x: 3*width/8, y: height/6, fixed: true },  
    { name: "hidden1", group: 3, size: 25, x: width/2, y: height/3, fixed: true },
    { name: "hidden2", group: 4, size: 25, x: width/2, y: 2*height/3, fixed: true },

//      { name: "biasOut", group: 5, size: 25, x: 5*width/8, y: height/6, fixed: true },  
    { name: "out1", group: 4, size: 25, x: 3*width/4, y: height/2, fixed: true }
  ],
  links: [  //source & target: index in nodes array,   value:  strength of link 
      
    { source: 0, target: 2, value: 10, display: true },
    { source: 0, target: 3, value: 10, display: true },

    { source: 1, target: 2, value: 10, display: true },
    { source: 1, target: 3, value: 10, display: true },
      
  //  { source: 2, target: 3, value: 10, display: true },
 //   { source: 2, target: 4, value: 10, display: true },

 //   { source: 5, target: 6, value: 10, display: true },
    
    { source: 2, target: 4, value: 10, display: true },
    { source: 3, target: 4, value: 10, display: true },
     
  ]
};
*/

//1 = 1/2
//2 = 1/4
//3 = 1/8



function buildFullyConnectedNodeGraph(sizes) {
  var margin = 0,
      length = sizes.length,
      n = d3.sum(sizes) * parseInt(length),
      xScale = d3.scale.linear()
                       .domain([0, length])
                       .range([margin, width-margin]),
      namePrefix = function(index) { 
                    if(index == 0) return "in";
                    else if(index == length-1) return "out";
                    else return "hiddenL" + index;
                  };

  var nodes = sizes.map(function(d, i) { 

              var midpoint = height/2;
              var num_nodes = d;



              var yScale = d3.scale.linear()
                          .domain([0, d])
                          .range([margin+(height/(d+1)), height-(margin+(height/(d+1)))]);

              return d3.range(d).map(function(x, j) {
                return {
                  layer: i,
                  index: j,
                  name: namePrefix(i) + "n" + j,
                  size: 25,
                  fixed: true,
                  x: xScale(i),
                  y: yScale(j)
                }  
              })
         }).reduce(function(d1,d2){ 
            return d1.concat(d2) 
         },[])
         .map(function(d, i) {
            d.group = i;
            return d;
         });
  
  var links = nodes.filter(function(d) {
    return d.layer != (length-1);
  }).map(function(d) {
    return nodes.filter(function(x) {
      return x.layer == (d.layer + 1)
    }).map(function(x) {
      return {
        source: d.group,
        target: x.group,
        value: 10,
        display: true
      }
    });
  }).reduce(function(d1,d2){ 
            return d1.concat(d2) 
  },[]);

  return {
    nodes: nodes,
    links: links
  }
}

var graphMLPData = buildFullyConnectedNodeGraph([4,3,2,1]);









var svg = d3.select("#netoworkGraphContainer").append("svg")
    .attr("width", width)
    .attr("height", height);

    function update(data) {


        var force = d3.layout.force()
                      .size([width, height])
                      .nodes(data.nodes)
                      .links(data.links)
                      .linkDistance(width/4);

        var links = svg.selectAll('.link')
            .data(data.links);

        links.enter()
             .append('line')
             .attr('class', 'link');

        var nodes = svg.selectAll(".node")
                      .data(data.nodes, function(d) { return d.name; }); //key fn
                      
        nodes.enter()
             .append("circle")
             .attr('class','node');

        //Set up tooltip
        var tip = d3.tip()
            .attr('class', 'd3-tip')
            .offset([-10, 0])
            .html(function (d) {
               return "<strong>" + d.name + "</strong><br/>" + d.size; //can be any html text if we want
            });
            svg.call(tip);

        nodes.on('mouseover', tip.show) 
             .on('mouseout', tip.hide); 

        force.on('tick', function() {

            nodes.attr({
                r: function(d) { return d.size; },
                cx: function(d) { return d.x; },
                cy: function(d) { return d.y; }
            });

            links.attr({
                x1: function(d) { return d.source.x; },
                y1: function(d) { return d.source.y; },
                x2: function(d) { return d.target.x; },
                y2: function(d) { return d.target.y; }
            });

        });

        force.start();

    }

    update(graphMLPData);


</script>
  

</body>

</html>