<!DOCTYPE html>
<meta charset="utf-8">
<meta http-equiv="Access-Control-Allow-Origin" content="*"/>

<style>

svg {
  /*position: absolute;*/
}

g.node {
  stroke: #fff;
  stroke-width: 1.5px;
}

line.link {
  stroke: #bdbdbd; /*#999;*/
  stroke-opacity: .6;
}

.d3-tip {
    line-height: 1;
    color: black;
    font-family: Arial;
    text-align: center;
}

.g-premium circle, circle.premium {
    fill: #00a3e0;
}
.g-claim circle, circle.claim {
    fill: #e4002b;

}

line.divider {
    stroke: #000; /*#666;*/
    stroke-width: 1;
}

circle.filler.outline {
    fill: #000;
    stroke: #000;
    stroke-width: 1.5;
}

</style>

<script type='text/javascript' src="./src/d3.v3.min.js"></script>
<script type='text/javascript' src="./src/d3.tip.js"> </script>
<script type="text/javascript" src='./src/math.js'></script>
<script type="text/javascript" src='./src/neural_network.js'></script>

<body>

  <div id="netoworkGraphContainer">
  </div>
  
  <div id="imageGenerator">
  </div>

<script>



//var training_data = [];
//var test_data = [];


//TODO: test self.backprop & write self.evaluate fns
  

var training_data = [
    { value: math.matrix([[0],[0]]), target: [[0]] },
    { value: math.matrix([[0],[1]]), target: [[0]] },
    { value: math.matrix([[1],[0]]), target: [[0]] },
    { value: math.matrix([[1],[1]]), target: [[1]] }
  ];

//2 (input), 2 (hidden layer1), 1 (output)
var myNetwork = new NeuralNetwork([2,2,1]);

//testing backprop alg:
//myNetwork.backprop(training_data[0].value, training_data[0].target);

//testing feed forward:
//myNetwork.feedForward(training_data[0].value);

//testing update_mini_batch:
//myNetwork.update_mini_batch(training_data, 1)

//testing SGD alg:
//myNetwork.SGD(training_data, 5, training_data.length, 1);

/*
function updateImage(dataRow) {

  var imgSVG = d3.select("#imageGenerator svg g");

  //data join
  var rect = imgSVG.selectAll('rect')
                   .data(dataRow.values);

  //note: assume square, so image is dimension*dimension
  var dimension = math.sqrt(dataRow.values.length);
  var pixelDimensions = 10;

  //update old elements as needed [only if enter().append("rect") is removed]

  function updatePixels(elem) {
    elem.attr({
    //rect.enter().append("rect")
        //.attr({
          width: pixelDimensions,
          height: pixelDimensions,
          x: function(d, i) {
            return pixelDimensions * parseInt(i % dimension);
          },
          y: function(d, i) {
            return pixelDimensions * parseInt(i / dimension);
          }
        }).style({
          fill: function (d,i) {
            return "rgb(" + d + "," + d + "," + d + ")";
          }
        });
  }

  updatePixels(rect);
  
  updatePixels(rect.enter().append("rect"));
    
  rect.exit().remove();

}



//d3.csv("./data/mnist_train_sample.csv", function(data) {
d3.text("./data/mnist_train_sample.csv", function(text) {
                      training_data = d3.csv.parseRows(text)
                                        .map(function(row) {
                                          return {
                                            result: +row.slice(0,1),
                                            values: row.slice(1).map(function(value) { return +value; })
                                          };
                                        });

                      var svg = d3.select("#imageGenerator")
                                  .append("svg")
                                  .attr({
                                    width: 280,
                                    height: 280
                                  })
                                  .append("g");

                      updateImage(training_data[0]);

                      //readyCheck("mnist_train_sample.csv");
                    });
*/

//var readyFiles = {'mnist_train_sample.csv': false, 'mnist_train_sample.csv': false};
//function readyCheck(filename) {
  //readyFiles[filename] = true;
//
  //if (readyFiles['mnist_train_sample']==true && readyFiles['mnist_train_sample']==true) {
    ////...begin drawing visualization...
//
  //}
//}





var width = 500,
    height = 500,
    minCircleRadius = 0;


var graphMLPData = {
  nodes: [
    { name: "in1", group: 0, size: 25, x: width/4, y: height/3, fixed: true },
    { name: "in2", group: 1, size: 25, x: width/4, y: 2*height/3, fixed: true },


      { name: "biashidden1", group: 2, size: 25, x: 3*width/8, y: height/6, fixed: true },  
    { name: "hidden1", group: 3, size: 25, x: width/2, y: height/3, fixed: true },
    { name: "hidden2", group: 4, size: 25, x: width/2, y: 2*height/3, fixed: true },

      { name: "biasOut", group: 5, size: 25, x: 5*width/8, y: height/6, fixed: true },  
    { name: "out1", group: 6, size: 25, x: 3*width/4, y: height/2, fixed: true }
  ],
  links: [  //source & target: index in nodes array,   value:  strength of link 
      
    { source: 0, target: 3, value: 10, display: true },
    { source: 0, target: 4, value: 10, display: true },

    { source: 1, target: 3, value: 10, display: true },
    { source: 1, target: 4, value: 10, display: true },
      
    { source: 2, target: 3, value: 10, display: true },
    { source: 2, target: 4, value: 10, display: true },

    { source: 5, target: 6, value: 10, display: true },
    
    { source: 3, target: 6, value: 10, display: true },
    { source: 4, target: 6, value: 10, display: true },
     
  ]
};




var svg = d3.select("#netoworkGraphContainer").append("svg")
    .attr("width", width)
    .attr("height", height);

    function update(data) {


        var force = d3.layout.force()
                      .size([width, height])
                      .nodes(data.nodes)
                      .links(data.links)
                      .linkDistance(width/4);

        var links = svg.selectAll('.link')
            .data(data.links);

        links.enter()
             .append('line')
             .attr('class', 'link');

        var nodes = svg.selectAll(".node")
                      .data(data.nodes, function(d) { return d.name; }); //key fn
                      
        nodes.enter()
             .append("circle")
             .attr('class','node');

        //Set up tooltip
        var tip = d3.tip()
            .attr('class', 'd3-tip')
            .offset([-10, 0])
            .html(function (d) {
               return "<strong>" + d.name + "</strong><br/>" + d.size; //can be any html text if we want
            });
            svg.call(tip);

        nodes.on('mouseover', tip.show) 
             .on('mouseout', tip.hide); 

        force.on('tick', function() {

            nodes.attr({
                r: function(d) { return d.size; },
                cx: function(d) { return d.x; },
                cy: function(d) { return d.y; }
            });

            links.attr({
                x1: function(d) { return d.source.x; },
                y1: function(d) { return d.source.y; },
                x2: function(d) { return d.target.x; },
                y2: function(d) { return d.target.y; }
            });

        });

        force.start();

    }

    update(graphMLPData);


</script>
  

</body>

</html>