<!DOCTYPE html>
<meta charset="utf-8">
<meta http-equiv="Access-Control-Allow-Origin" content="*"/>

<link class="main-stylesheet" href="./styles/css/styles.css" rel="stylesheet" type="text/css" />

<script type='text/javascript' src="./src/d3.v3.min.js"></script>
<script type='text/javascript' src="./src/d3.tip.js"> </script>
<script type="text/javascript" src='./src/math.js'></script>
<script type="text/javascript" src='./src/neural_network.js'></script>

<body>

  <div id="netoworkGraphContainer">
  </div>
  
  <div id="imageGenerator">
  </div>

<script>

var AND_training_data = [
    { value: math.matrix([[0],[0]]), target: [[0]] },
    { value: math.matrix([[0],[1]]), target: [[0]] },
    { value: math.matrix([[1],[0]]), target: [[0]] },
    { value: math.matrix([[1],[1]]), target: [[1]] }
  ],
  OR_training_data = [
    { value: math.matrix([[0],[0]]), target: [[0]] },
    { value: math.matrix([[0],[1]]), target: [[1]] },
    { value: math.matrix([[1],[0]]), target: [[1]] },
    { value: math.matrix([[1],[1]]), target: [[1]] }
  ],
  XOR_training_data = [
    { value: math.matrix([[0],[0]]), target: [[0]] },
    { value: math.matrix([[0],[1]]), target: [[1]] },
    { value: math.matrix([[1],[0]]), target: [[1]] },
    { value: math.matrix([[1],[1]]), target: [[0]] }
  ];

//2 (input), 1 (output)  <no hidden layers>
var mySimpleNetwork = new NeuralNetwork([2,1]);
//mySimpleNetwork.train(AND_training_data, 5000, AND_training_data.length, 0.25);
//mySimpleNetwork.evaluate(AND_training_data);

//2 (input), 2 (hidden layer1), 1 (output)
var myNetwork = new NeuralNetwork([2,2,1]);
//myNetwork.train(AND_training_data, 5000, AND_training_data.length, 0.25);
//myNetwork.evaluate(AND_training_data);

//784 (input), 30 (hidden layer1), 10 (output)
//var myCharacterRecognitionNetwork = new NeuralNetwork([784,30,10]);
//myCharacterRecognitionNetwork.train(img_training_data, 5000, img_training_data.length, 0.25);
//myCharacterRecognitionNetwork.evaluate(img_training_data);


var width = 500,
    height = 500;

function buildFullyConnectedNodeGraph(sizes, options, neuralNetwork) {

  function setOptions (standard, user) {
    if (typeof user === 'object') {
      for (var key in user) {
        standard[key] = user[key];
      }
    }
    return standard;
  }

  function flattenSimple (arr) {
    return arr.reduce(function(d1,d2) { return d1.concat(d2) },[]);
  }
  function unpack (matrix) {
    return flattenSimple(matrix._data);
  }


  var optionsDefault = {
    width: 500,
    height: 500,
    circleSize: 25,
    margin: 30
  };
  var options = setOptions(optionsDefault, options);

  var weights, biases;
  if (neuralNetwork !== undefined) {
    biases = flattenSimple(neuralNetwork.biases.map(function(x) { return unpack(x) }));
    weights = flattenSimple(neuralNetwork.weights.map(function(x) { return unpack(x) }));
  }


  var length = sizes.length,
      boundary = options.margin+options.circleSize,
      xScale = d3.scale.linear()
                       .domain([0, length])
                       .range([boundary, options.width-boundary]),
      namePrefix = function(index) { 
                    if(index == 0) return "IN";
                    else if(index == length-1) return "OUT";
                    else return "HiddenL" + (index);
                  };

  var nodes = sizes.map(function(d, i) { 

              return d3.range(d).map(function(x, j) {
                return {
                  layer: i,
                  index: j,
                  name: namePrefix(i) + "n" + (j+1),
                  size: options.circleSize,
                  fixed: true,
                  x: xScale(i),
                  y: (j+1)*options.height/(d+1)
                }  
              })
         }).reduce(function(d1,d2){ 
            return d1.concat(d2) 
         },[])
         .map(function(d, i) {
            d.group = i;
            
            if(neuralNetwork === undefined || d.layer == 0)
              d.bias = 1;
            else
              d.bias = biases[i-sizes[0]];
            
            return d;
         });
  
  var links = nodes.filter(function(d) {
    return d.layer != (length-1);
  }).map(function(d) {
    return nodes.filter(function(x) {
      return x.layer == (d.layer + 1)
    }).map(function(x) {
      return {
        source: d.group,
        target: x.group,
        value: 10,
        display: true
      }
    });
  }).reduce(function(d1,d2){ 
    return d1.concat(d2) 
  },[]).map(function(d, i) {
    if(neuralNetwork === undefined)
      d.weight = 10;
    else
      d.weight = weights[i];

    return d;
  });

  return {
    nodes: nodes, //nodes store biases
    links: links  //links store weights
  }
}

var graphMLPData = //buildFullyConnectedNodeGraph([2,2,1], {}, myNetwork);
      buildFullyConnectedNodeGraph([20,10,4,2,1], {circleSize: 8});
      //buildFullyConnectedNodeGraph([1,1]);


var svg = d3.select("#netoworkGraphContainer").append("svg")
    .attr("width", width)
    .attr("height", height);

    function update(data) {


        var force = d3.layout.force()
                      .size([width, height])
                      .nodes(data.nodes)
                      .links(data.links)
                      .linkDistance(width/4);

        var links = svg.selectAll('.link')
            .data(data.links);

        links.enter()
             .append('line')
             .attr('class', 'link');

        var nodes = svg.selectAll(".node")
                      .data(data.nodes, function(d) { return d.name; }); //key fn
                      
        nodes.enter()
             .append("circle")
             .attr('class','node');

        //Set up tooltip
        var tip = d3.tip()
            .attr('class', 'd3-tip')
            .offset([-10, 0])
            .html(function (d) {
               return "<strong>" + d.name + "</strong><br/>" + d.size; //can be any html text if we want
            });
            svg.call(tip);

        nodes.on('mouseover', tip.show) 
             .on('mouseout', tip.hide); 

        force.on('tick', function() {

            nodes.attr({
                r: function(d) { return d.size; },
                cx: function(d) { return d.x; },
                cy: function(d) { return d.y; }
            });

            links.attr({
                x1: function(d) { return d.source.x; },
                y1: function(d) { return d.source.y; },
                x2: function(d) { return d.target.x; },
                y2: function(d) { return d.target.y; }
            });

        });

        force.start();

    }

    update(graphMLPData);


</script>
  

</body>

</html>